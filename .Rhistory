n.spins = 60
spins = sample.int(37, size = n.spins, replace = T)
# Let's say odd numbers are red (0)
# Even numbers are black (1)
outcome = sapply(spins,
function(x) ifelse((x %% 2) == 0, 1, 0))
curr.bankroll = 100
for (i in 1:n.spins){
# GO HOme
if (curr.bankroll <= 0) break
# We see 5 blacks in a row
# We bet all on red.
# Outcome 1: IT is green.
if (spins[i] == 37){
curr.bankroll = curr.bankroll - 5
# Outcome 2: We get Red!
}else if (outcome[i] == 0){
curr.bankroll = curr.bankroll + 5
# Outcome 3: We get black :(
}else if (outcome[i] == 1){
curr.bankroll = curr.bankroll - 5
}
}
curr.bankroll
}
onenightB = function(){
n.spins = 60
spins = sample.int(37, size = n.spins, replace = T)
# Let's say odd numbers are red (0)
# Even numbers are black (1)
outcome = sapply(spins,
function(x) ifelse((x %% 2) == 0, 1, 0))
curr.bankroll = 100
for (i in 1:n.spins){
# GO HOme
if (curr.bankroll <= 0) break
# We see 5 blacks in a row
# We bet all on red.
# Outcome 1: IT is green.
if (spins[i] == 37){
curr.bankroll = curr.bankroll - 5
# Outcome 2: We get Red!
}else if (outcome[i] == 0){
curr.bankroll = curr.bankroll + 5
# Outcome 3: We get black :(
}else if (outcome[i] == 1){
curr.bankroll = curr.bankroll - 5
}
}
curr.bankroll
}
n = 1000
n = 1000
profits.per.day = vector("numeric", n)
for (i in 1:n){
profit = onenightB() - 100
profits.per.day = c(profits.per.day, profit)
}
hist(profits.per.day)
knitr::opts_chunk$set(echo = TRUE)
set.seed(5003)
theta = 0.7 # Probablity of heads
N = 200
coin.flips = rbinom(n = N, size = 1, prob = theta)
coin.flips
table(coin.flips)
set.seed(5003)
theta = 0.7 # Probablity of heads
N = 100
coin.flips = rbinom(n = N, size = 1, prob = theta)
table(coin.flips)
set.seed(5003)
theta = 0.7 # Probablity of heads
N = 200
coin.flips = rbinom(n = N, size = 1, prob = theta)
table(coin.flips)
likelihood = function(theta, x){
prod(dbinom(x, size = 1, prob = theta))
}
niters = 1000
curr.theta = 0.5
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = likelihood(curr.theta, coin.flips)
proposal.likeli = likelihood(proposal.theta, coin.flips)
alpha = min(proposal.likeli/curr.likeli , 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain)
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0.5
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain)
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain)
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0.7
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0.7
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0.5, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0.5, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.5)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.1)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (runif(1) < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
hist(theta.chain[75:1000], n = 30)
plot(theta.chain[70:1000], type = "l")
f <- function(x, mu = mn, sd = std)  p * dnorm(x, mu[1], sd[1]) + (1 - p) * dnorm(x, mu[2], sd[2])
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (0.2 < alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (0. 7< alpha){
log.likelihood = function(theta, x){
sum(dbinom(x, size = 1, prob = theta, log =T))
}
niters = 1000
curr.theta = 0
theta.chain = numeric(niters)
for (i in 0:(niters - 1)){
proposal.theta  = curr.theta + rnorm(1, mean = 0, sd = 0.05)
if (proposal.theta<0 || proposal.theta >1){
theta.chain[i+1] = curr.theta
next
}
curr.likeli = log.likelihood(curr.theta, coin.flips)
proposal.likeli = log.likelihood(proposal.theta, coin.flips)
alpha =  min(exp(proposal.likeli - curr.likeli), 1)
if (0.7< alpha){
curr.theta = proposal.theta
}
theta.chain[i + 1] = curr.theta
}
plot(theta.chain, type = "l")
D = matrix(c(
0 , 0.3 , 0.4 , 0.7,
0.3 , 0 , 0.5 , 0.8,
0.4 , 0.5 , 0 , 0.45,
0.7 , 0.8 , 0.45 , 0), 4, 4)
D = matrix(c(
0 , 0.4 , 0.3 , 0.9,
0.4, 0 , 0.8 , 0.7,
0.3 , 0.8 , 0 , 0.5,
0.9 , 0.7 , 0.5 , 0), 4, 4)
hclust(as.dist(D), method = "single")
dd = hclust(as.dist(D), method = "single")
d
dd$merge
?hclust
120 + 270 + 300
bills = 70
total = 120 + 270 + 300
rent = 630
bills = total - rent
bills
billspp = 60/3
billspp
mprop = (120 - 20)/rent
mprop = (120 - 20)/rent
yprop = (300 - 20)/rent
aprop = (270 - 20)/rent
mprop
mprop = (120 - 20)/rent |> round()
mprop
?round
mprop = (120 - 20)/rent |> round(digits = 2)
mprop
yprop
aprop
mprop + aprop
m.a.prop = mprop + aprop
mi.yas.prop = 1 - m.a.prop
mi.yas.prop
mi.yas.prop = 1 - m.a.prop
m.a.prop = mprop + aprop
m.a.prop
mi.yas.prop
mi.yas.total = mi.yas.prop * rent
mi.yas.total
m.a.total = m.a.prop * rent
m.a.total
yas.rent = 280
martin.rent = 100
anthea.rent = 250
yas.prop = yas.rent/rent
martin.prop = martin.rent/rent
anthea.prop = anthea.rent/rent
martin.prop
anthea.prop
yas.prop
anthea.prop.new = anthea.prop * micheal.prop*25
anthea.prop.new
micheal.prop = 0.25
anthea.prop.new = anthea.prop * micheal.prop*25
anthea.prop.new
anthea.prop.new = anthea.prop * micheal.prop
anthea.prop.new
anthea.prop * 25
anthea.prop.new = anthea.prop - anthea.prop * 25
anthea.prop.new
anthea.prop
anthea.prop * 25
anthea.prop - anthea.prop * 0.25
anthea.prop.new = anthea.prop - anthea.prop * 0.25
anthea.prop.new = anthea.prop - anthea.prop * 0.25
yas.prop.new = yas.prop - yas.prop * 0.25
martin.prop.new = martin.prop - martin.prop * 0.25
yas.prop.new
martin.prop.new
anthea.prop.new
anthea.rent.new = anthea.prop.new * rent
yas.rent.new = yas.prop.new * rent
martin.rent.new = martin.prop.new * rent
micheal.rent.new = micheal.prop.new * rent
anthea.rent.new = anthea.prop.new * rent
yas.rent.new = yas.prop.new * rent
martin.rent.new = martin.prop.new * rent
micheal.rent.new = micheal.prop * rent
anthea.rent.new
yas.rent.new
martin.rent.new
micheal.rent.new
new.rent = function(micheal.prop){
anthea.prop.new = anthea.prop - anthea.prop * micheal.prop
yas.prop.new = yas.prop - yas.prop * micheal.prop
martin.prop.new = martin.prop - martin.prop * micheal.prop
anthea.rent.new = anthea.prop.new * rent
yas.rent.new = yas.prop.new * rent
martin.rent.new = martin.prop.new * rent
micheal.rent.new = micheal.prop * rent
paste("Anthea pays:", anthea.rent.new, "\n",
"Yasmin pays:", yas.rent.new, "\n",
"Martin pays:", martin.rent.new, "\n",
"Micheal pays:", micheal.rent.new)
}
new.rent(0.25)
new.rent = function(micheal.prop){
anthea.prop.new = anthea.prop - anthea.prop * micheal.prop
yas.prop.new = yas.prop - yas.prop * micheal.prop
martin.prop.new = martin.prop - martin.prop * micheal.prop
anthea.rent.new = anthea.prop.new * rent
yas.rent.new = yas.prop.new * rent
martin.rent.new = martin.prop.new * rent
micheal.rent.new = micheal.prop * rent
paste("Anthea pays:\n", anthea.rent.new, "\n",
"Yasmin pays:", yas.rent.new, "\n",
"Martin pays:", martin.rent.new, "\n",
"Micheal pays:", micheal.rent.new)
}
new.rent(0.25)
new.rent = function(micheal.prop){
anthea.prop.new = anthea.prop - anthea.prop * micheal.prop
yas.prop.new = yas.prop - yas.prop * micheal.prop
martin.prop.new = martin.prop - martin.prop * micheal.prop
anthea.rent.new = anthea.prop.new * rent
yas.rent.new = yas.prop.new * rent
martin.rent.new = martin.prop.new * rent
micheal.rent.new = micheal.prop * rent
cat("Anthea pays:", anthea.rent.new, "\n",
"Yasmin pays:", yas.rent.new, "\n",
"Martin pays:", martin.rent.new, "\n",
"Micheal pays:", micheal.rent.new)
}
new.rent(0.25)
new.rent(0.16)
new.rent(0.2)
280/rent
(224 + 126)/rent
310+290
290/560
270/560
0.62 * 630
0.2 * 630
0.52 * 630
maritn.rent/370
martin.rent/350
anthea.rent/350
(anthea.rent/350) * 327.6
(martin.rent/350) * 327.6
60/4
setwd("~/Library/CloudStorage/OneDrive-Personal/PhD/2024/Stability/Automatic Threshold Selection")
#  for Stability Selection (Huang et al. 2025)                      #
#                                                                   #
# Author: Martin Huang (martin.huang@sydney.edu.au)                 #
#         School of Mathematics & Statistics, University of Sydney  #
#         AUSTRALIA                                                 #
# Note: This will take more than 24 hours without parallelisation.  #
#       I have provided the Rdata file for my simulations.          #
#       Please see Example-Figure-Code.R for code to visualise      #
#       results                                                     #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
source("Functions.R")
# Each Rdata file contains 4 SNRs for their respective simulation.
load("RData/S1hardR.Rdata")
load("RData/S2hardR.Rdata")
load("RData/S3hardR.Rdata")
load("RData/S4hardR.Rdata")
source("Functions.R")
load("RData/S1hardR.Rdata")
load("RData/S2hardR.Rdata")
load("RData/S3hardR.Rdata")
load("RData/S4hardR.Rdata")
#---#---#---#---#---#---#---#---#---#---#---#---#---#---
# MCC Artificial Data
filtered = c("ATS", "Exclusion ATS",
"Static 0.60","Static 0.75", "Static 0.90", "LASSO 1SE", "Knockoff", "SCAD")
repeats = 1000
c11hard = combine(S1.10hard, S1.5hard, S1.3hard, S1.1hard, 1, filtered = filtered) |> makeCluster()
c22hard = combine(S2.10hard, S2.5hard, S2.3hard, S2.1hard, 2, filtered = filtered) |> makeCluster()
c33hard = combine(S3.10hard, S3.5hard, S3.3hard, S3.1hard, 3, filtered = filtered) |> makeCluster()
c44hard = combine(S4.10hard, S4.5hard, S4.3hard, S4.1hard, 4, filtered = filtered) |> makeCluster()
c1hard = rbind(c11hard,c22hard) |> totplotnoaxis()
c2hard = rbind(c33hard,c44hard) |> totplot()
library(patchwork)
c1hard/c2hard
warnings()
